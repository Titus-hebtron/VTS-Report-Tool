"""
Export `users` from local SQLite (`vts_database.db`) to a Postgres-compatible SQL file
and optionally insert them directly into a reachable Postgres database while preserving
password hashes.

Usage examples:
  # produce SQL dump only
  python export_users_sqlite_to_postgres.py --dump users_dump.sql

  # attempt direct insert (uses TARGET_PG_URL env var or --target)
  export TARGET_PG_URL="postgresql://user:pass@host:5432/dbname?sslmode=require"
  python export_users_sqlite_to_postgres.py --apply

The script preserves `password_hash` values exactly and writes INSERT statements
using ON CONFLICT (username) DO NOTHING to avoid duplicates.
"""
import sqlite3
import argparse
import os
import sys
from datetime import datetime

try:
    from sqlalchemy import create_engine, text
    from sqlalchemy.exc import SQLAlchemyError
except Exception:
    create_engine = None


SQLITE_FILE = "vts_database.db"
DEFAULT_DUMP = "users_dump.sql"


def read_users_from_sqlite(sqlite_path=SQLITE_FILE):
    if not os.path.exists(sqlite_path):
        raise FileNotFoundError(f"SQLite DB not found: {sqlite_path}")
    conn = sqlite3.connect(sqlite_path)
    conn.row_factory = sqlite3.Row
    cur = conn.cursor()
    # Read columns to preserve available columns
    cur.execute("PRAGMA table_info(users)")
    cols = [r[1] for r in cur.fetchall()]
    # Ensure we at least have id, username, password_hash
    if "username" not in cols or "password_hash" not in cols:
        raise RuntimeError("`users` table missing required columns (username, password_hash)")
    cur.execute("SELECT * FROM users")
    rows = [dict(r) for r in cur.fetchall()]
    conn.close()
    return cols, rows


def pg_escape(val):
    if val is None:
        return "NULL"
    if isinstance(val, (int, float)):
        return str(val)
    s = str(val)
    s = s.replace("'", "''")
    return f"'{s}'"


def generate_sql_dump(cols, rows, dump_path):
    # Use explicit columns ordering
    col_list = cols
    with open(dump_path, "w", encoding="utf-8") as f:
        f.write("-- users SQL dump generated by export_users_sqlite_to_postgres.py\n")
        f.write("BEGIN;\n")
        for r in rows:
            values = [pg_escape(r.get(c)) for c in col_list]
            colnames = ", ".join(col_list)
            valstr = ", ".join(values)
            stmt = f"INSERT INTO users ({colnames}) VALUES ({valstr}) ON CONFLICT (username) DO NOTHING;\n"
            f.write(stmt)
        # update sequence if id column exists
        if "id" in col_list and rows:
            max_id = max((r.get("id") or 0) for r in rows)
            f.write(f"SELECT setval(pg_get_serial_sequence('users','id'), {max_id}, true);\n")
        f.write("COMMIT;\n")
    print(f"✅ Wrote {len(rows)} users to SQL dump: {dump_path}")


def apply_to_postgres(target_url, cols, rows):
    if create_engine is None:
        raise RuntimeError("SQLAlchemy not available in this environment; cannot apply to Postgres")
    # Ensure sslmode
    if "sslmode" not in target_url:
        if "?" in target_url:
            target_url = target_url + "&sslmode=require"
        else:
            target_url = target_url + "?sslmode=require"
    try:
        engine = create_engine(target_url)
        with engine.begin() as conn:
            inserted = 0
            for r in rows:
                params = {c: r.get(c) for c in cols}
                # Use parameterized INSERT with ON CONFLICT
                colnames = ", ".join(cols)
                placeholders = ", ".join([f":{c}" for c in cols])
                stmt = text(f"INSERT INTO users ({colnames}) VALUES ({placeholders}) ON CONFLICT (username) DO NOTHING")
                try:
                    conn.execute(stmt, params)
                    inserted += 1
                except Exception as e:
                    print(f"  warning: failed to insert user {r.get('username')}: {e}")
            # fix sequence
            if "id" in cols and rows:
                max_id = max((r.get("id") or 0) for r in rows)
                conn.execute(text(f"SELECT setval(pg_get_serial_sequence('users','id'), :max_id, true)"), {"max_id": max_id})
        print(f"✅ Inserted/attempted {inserted} users into Postgres")
    except SQLAlchemyError as e:
        raise


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--dump", "-d", help="Write SQL dump to this file (default users_dump.sql)", default=DEFAULT_DUMP)
    parser.add_argument("--apply", "-a", help="Attempt to apply directly to Postgres using TARGET_PG_URL env var or --target", action="store_true")
    parser.add_argument("--target", "-t", help="Postgres target URL (overrides TARGET_PG_URL env)")
    args = parser.parse_args()

    try:
        cols, rows = read_users_from_sqlite()
    except Exception as e:
        print("❌ Error reading users from SQLite:", e)
        sys.exit(2)

    # Always produce dump file
    dump_path = args.dump
    generate_sql_dump(cols, rows, dump_path)

    if args.apply:
        target = args.target or os.getenv("TARGET_PG_URL") or os.getenv("DATABASE_URL")
        if not target:
            print("❌ No target Postgres URL provided; set TARGET_PG_URL env var or use --target")
            sys.exit(3)
        print("Attempting to connect to Postgres (masked):", (target[:60] + "..."))
        try:
            apply_to_postgres(target, cols, rows)
        except Exception as e:
            print("❌ Failed to apply to Postgres:", e)
            sys.exit(4)


if __name__ == '__main__':
    main()
